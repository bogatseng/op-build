From 594a28d2e37760f0ba6f3fb946c4ebe232917d8a Mon Sep 17 00:00:00 2001
From: Dean Sanner <dsanner@us.ibm.com>
Date: Fri, 19 Aug 2016 11:31:40 -0500
Subject: [PATCH] Add vendor to proc/motherboard devtree, tweak fw versions

Enable LOCATION_CODE ATTR to be used as location in
device tree.  This can be set in MRW in the "connection"
parts for pluggable FRUs

Change-Id: Iafbdd766901ab685b0f3a739354b2b927beaaa92
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/28540
Tested-by: Jenkins Server <pfd-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP Build CI <op-jenkins+hostboot@us.ibm.com>
Tested-by: Jenkins OP HW <op-hw-jenkins+hostboot@us.ibm.com>
Reviewed-by: William G. Hoffa <wghoffa@us.ibm.com>
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Daniel M. Crowell <dcrowell@us.ibm.com>
---
 src/usr/devtree/bld_devtree.C                      | 272 ++++++++++++++++++---
 src/usr/targeting/common/Targets.pm                |   1 -
 src/usr/targeting/common/processMrw.pl             |  36 ++-
 .../common/xmltohb/attribute_types_hb.xml          |  16 ++
 .../targeting/common/xmltohb/target_types_hb.xml   |  10 +
 src/usr/targeting/common/xmltohb/xmltohb.pl        |  44 ++++
 6 files changed, 340 insertions(+), 39 deletions(-)

diff --git a/src/usr/devtree/bld_devtree.C b/src/usr/devtree/bld_devtree.C
index a732903..f7861fd 100644
--- a/src/usr/devtree/bld_devtree.C
+++ b/src/usr/devtree/bld_devtree.C
@@ -99,6 +99,36 @@ enum BuildConstants
     CEN_ID_TAG          = 0x80000000,
 };
 
+void str_chomp(char* i_str)
+{
+    size_t len = strlen(i_str);
+    ssize_t i;
+
+    //Walk from the back of the str and find first
+    //non white space char
+    for(i = (len-1); i >=0; i--)
+    {
+        if((i_str[i] != ' ') &&
+           (i_str[i] != '\t') &&
+           (i_str[i] != '\n') &&
+           (i_str[i] != '\v') &&
+           (i_str[i] != '\f') &&
+           (i_str[i] != '\r'))
+        {
+            //real char --> exit loop
+            break;
+        }
+    }
+
+    // put end of str after first real char
+    // note if we fell through loop 'i' will be -1
+    // so we will return an empty str
+    i_str[i+1] = '\0';
+
+    return;
+}
+
+
 errlHndl_t readSPD(TARGETING::Target * i_dimm,
                    std::vector<uint8_t> &io_data,
                    uint8_t i_keyword)
@@ -916,19 +946,33 @@ errlHndl_t bld_xscom_node(devTree * i_dt, dtOffset_t & i_parentNode,
     i_dt->addPropertyString(xscomNode, "ecid", ecid_ascii);
     CPPASSERT(sizeof(ATTR_ECID_type) == 16);
 
-    //Add location string
-    TARGETING::EntityPath ep = i_pProc->getAttr<TARGETING::ATTR_PHYS_PATH>();
-    i_dt->addPropertyString(xscomNode, "location",ep.toString());
+    //Add location string.  Try location code first, if that isn't
+    //populated then fall back to phys path
+    ATTR_LOCATION_CODE_type l_loc_str = {'\0'};
+    if(i_pProc->tryGetAttr<ATTR_LOCATION_CODE>(l_loc_str)
+       && strlen(l_loc_str))
+    {
+        i_dt->addPropertyString(xscomNode, "ibm,slot-location-code",l_loc_str);
+    }
+    else
+    {
+        TARGETING::EntityPath ep =
+          i_pProc->getAttr<TARGETING::ATTR_PHYS_PATH>();
+        i_dt->addPropertyString(xscomNode, "ibm,slot-location-code",
+                                ep.toString());
+    }
 
     //Add Product Part Number
-    TARGETING::ATTR_PART_NUMBER_type l_pn = {'0'};
+    TARGETING::ATTR_PART_NUMBER_type l_pn = {'\0'};
     i_pProc->tryGetAttr<TARGETING::ATTR_PART_NUMBER>(l_pn);
+    str_chomp(reinterpret_cast<char*>(l_pn));
     i_dt->addPropertyString(xscomNode, "part-number",
                             reinterpret_cast<char*>(&l_pn[0]));
 
     //Add Product Serial Number
-    TARGETING::ATTR_SERIAL_NUMBER_type l_sn = {'0'};
+    TARGETING::ATTR_SERIAL_NUMBER_type l_sn = {'\0'};
     i_pProc->tryGetAttr<TARGETING::ATTR_SERIAL_NUMBER>(l_sn);
+    str_chomp(reinterpret_cast<char*>(l_sn));
     i_dt->addPropertyString(xscomNode, "serial-number",
                             reinterpret_cast<char*>(&l_sn[0]));
 
@@ -936,9 +980,28 @@ errlHndl_t bld_xscom_node(devTree * i_dt, dtOffset_t & i_parentNode,
     errhdl = readVPD(i_pProc, l_data,  DeviceFW::MVPD, MVPD::VINI, MVPD::DR);
     if (errhdl) { return errhdl; }
     l_data.push_back('\0');
+    str_chomp(reinterpret_cast<char*>(&l_data[0]));
+
+    //Slight hack to distinguish IBM vs non IBM processors
+    if(strcmp(reinterpret_cast<char*>(&l_data[0]), "PROCESSOR MODULE") == 0)
+    {
+        //tweak it to say "IBM PROC MODULE".  Note new string is smaller
+        strcpy (reinterpret_cast<char*>(&l_data[0]),
+                "IBM PROC MODULE");
+    }
     i_dt->addPropertyString(xscomNode, "board-info",
                             reinterpret_cast<char*>(&l_data[0]));
 
+    //Add Vendor.  First full word of DR, space delimited for P8
+    char* l_loc = strchr(reinterpret_cast<char*>(&l_data[0]), ' ');
+    if(l_loc) //Found insert a NULL char, otherwise it is the full string
+    {
+        *l_loc = '\0';
+    }
+    i_dt->addPropertyString(xscomNode, "vendor",
+                            reinterpret_cast<char*>(&l_data[0]));
+
+
     //Add Powerbus frequency
     i_dt->addPropertyCell32(xscomNode, "powerbus-frequency-mhz",
                             sys->getAttr<TARGETING::ATTR_FREQ_PB>());
@@ -1655,6 +1718,7 @@ errlHndl_t bld_fdt_system(devTree * i_dt, bool i_smallTree)
                     else
                     {
                         foundvpd = true;
+                        str_chomp(drBuf);
                         i_dt->addPropertyString(rootNode, "model", drBuf);
                     }
                 }
@@ -1677,6 +1741,7 @@ errlHndl_t bld_fdt_system(devTree * i_dt, bool i_smallTree)
                 else
                 {
                     foundvpd = true;
+                    str_chomp(mmBuf);
                     i_dt->addPropertyString(rootNode, "model", mmBuf);
                 }
             }
@@ -1741,16 +1806,37 @@ errlHndl_t bld_fdt_system(devTree * i_dt, bool i_smallTree)
                 }
             }
 
+            //Add Vendor
+            std::vector<uint8_t> l_data;
+            errhdl = readVPD(l_pNode, l_data,  DeviceFW::PVPD,
+                             PVPD::OPFR, PVPD::VN);
+            // just delete any errors we get, this isn't critical
+            if( errhdl )
+            {
+                delete errhdl;
+                errhdl = NULL;
+                i_dt->addPropertyString(rootNode, "vendor", "unavailable");
+            }
+            else
+            {
+                l_data.push_back('\0');
+                str_chomp(reinterpret_cast<char*>(&l_data[0]));
+                i_dt->addPropertyString(rootNode, "vendor",
+                                        reinterpret_cast<char*>(&l_data[0]));
+            }
+
             //Add FRU info
             //Add Product Part Number
-            TARGETING::ATTR_PART_NUMBER_type l_pn = {'0'};
+            TARGETING::ATTR_PART_NUMBER_type l_pn = {'\0'};
             l_pNode->tryGetAttr<TARGETING::ATTR_PART_NUMBER>(l_pn);
+            str_chomp(reinterpret_cast<char*>(&l_pn[0]));
             i_dt->addPropertyString(rootNode, "part-number",
                                     reinterpret_cast<char*>(&l_pn[0]));
 
             //Add Product Serial Number
-            TARGETING::ATTR_SERIAL_NUMBER_type l_sn = {'0'};
+            TARGETING::ATTR_SERIAL_NUMBER_type l_sn = {'\0'};
             l_pNode->tryGetAttr<TARGETING::ATTR_SERIAL_NUMBER>(l_sn);
+            str_chomp(reinterpret_cast<char*>(&l_sn[0]));
             i_dt->addPropertyString(rootNode, "serial-number",
                                     reinterpret_cast<char*>(&l_sn[0]));
         }
@@ -1995,10 +2081,35 @@ errlHndl_t bld_fdt_dimm(devTree * i_dt, dtOffset_t i_membNode, Target* i_memBuf)
                 uint64_t propertyCells[2] = {l_portdimm, l_bytes};
                 i_dt->addPropertyCells64(dimmNode, "reg", propertyCells, 2);
 
-
-                TARGETING::EntityPath ep =
-                  l_dimm->getAttr<TARGETING::ATTR_PHYS_PATH>();
-                i_dt->addPropertyString(dimmNode, "location",ep.toString());
+                //Add location string.  Try location code first, if that isn't
+                //populated then fall back to phys path
+                ATTR_LOCATION_CODE_type l_loc_str = {'\0'};
+                char * l_pstr = l_loc_str;
+                if(l_dimm->tryGetAttr<ATTR_LOCATION_CODE>(l_loc_str) &&
+                   strlen(l_loc_str))
+                {
+                    //check to see if membuffer has loc string... if so
+                    //then it is on a pluggable card, need to prepend
+                    char l_tmp_str[(ATTR_LOCATION_CODE_max_chars*2) +1] ={'\0'};
+                    ATTR_LOCATION_CODE_type l_mb_str = {'\0'};
+                    if(i_memBuf->tryGetAttr<ATTR_LOCATION_CODE>(l_mb_str)
+                       && strlen(l_mb_str))
+                    {
+                        strcpy(l_tmp_str, l_mb_str);
+                        strcat(l_tmp_str, "-");
+                        strcat(l_tmp_str, l_loc_str);
+                        l_pstr = l_tmp_str;
+                    }
+                    i_dt->addPropertyString(dimmNode, "ibm,slot-location-code",
+                                            l_pstr);
+                }
+                else
+                {
+                    TARGETING::EntityPath ep =
+                      l_dimm->getAttr<TARGETING::ATTR_PHYS_PATH>();
+                    i_dt->addPropertyString(dimmNode, "ibm,slot-location-code",
+                                            ep.toString());
+                }
 
                 if(l_dimm->getAttr<TARGETING::ATTR_HWAS_STATE>().present
                    != true)
@@ -2007,12 +2118,15 @@ errlHndl_t bld_fdt_dimm(devTree * i_dt, dtOffset_t i_membNode, Target* i_memBuf)
                     continue;
                 }
 
-                i_dt->addProperty(dimmNode, "present");
-                //Set property to indicate fault (not using)
+                //Set property to indicate disabled (not using)
                 if(l_dimm->getAttr<TARGETING::ATTR_HWAS_STATE>().functional
                    != true)
                 {
-                    i_dt->addProperty(dimmNode, "fault");
+                    i_dt->addPropertyString(dimmNode, "status", "disabled");
+                }
+                else
+                {
+                    i_dt->addPropertyString(dimmNode, "status", "okay");
                 }
 
                 //Set Manufacturer's Name - Use JEDEC standard MFG ID
@@ -2024,20 +2138,13 @@ errlHndl_t bld_fdt_dimm(devTree * i_dt, dtOffset_t i_membNode, Target* i_memBuf)
                 //Set DDR type - Use Basic SPD Memory Type
                 errhdl = readSPD(l_dimm, l_data,  SPD::BASIC_MEMORY_TYPE);
                 if (errhdl) { break; }
-                const char * ddr_type = "unknown";
-                if (SPD::SPD_DDR3 == l_data[0])
-                {
-                    ddr_type = "ddr3";
-                }else if (SPD::SPD_DDR4 == l_data[0])
-                {
-                    ddr_type = "ddr4";
-                }
-                i_dt->addPropertyString(dimmNode, "spd-memory-type", ddr_type);
+                i_dt->addPropertyCell32(dimmNode, "memory-id", l_data[0]);
 
                 //Set Product Part/Model Number
                 errhdl = readSPD(l_dimm, l_data,  SPD::MODULE_PART_NUMBER);
                 if (errhdl) { break; }
                 l_data.push_back('\0');
+                str_chomp(reinterpret_cast<char*>(&l_data[0]));
                 i_dt->addPropertyString(dimmNode, "part-number",
                                         reinterpret_cast<char*>(&l_data[0]));
 
@@ -2223,9 +2330,28 @@ errlHndl_t bld_fdt_mem(devTree * i_dt, bool i_smallTree)
             i_dt->addPropertyCell32(membNode, "#address-cells", 1);
             i_dt->addPropertyCell32(membNode, "#size-cells", 1);
 
-            TARGETING::EntityPath ep =
-              l_mb->getAttr<TARGETING::ATTR_PHYS_PATH>();
-            i_dt->addPropertyString(membNode, "location",ep.toString());
+            //If the CENTAUR_ECID_FRU_ID is 0xFF then this membuf is on a
+            //fru (riser card).  Add location string.
+            //  Try location code first, if that isn't
+            //populated then fall back to phys path
+            if(l_mb->getAttr<TARGETING::ATTR_CENTAUR_ECID_FRU_ID>() == 0xFF)
+            {
+
+                ATTR_LOCATION_CODE_type l_loc_str = {'\0'};
+                if(l_mb->tryGetAttr<ATTR_LOCATION_CODE>(l_loc_str)
+                   && strlen(l_loc_str))
+                {
+                    i_dt->addPropertyString(membNode, "ibm,slot-location-code",
+                                            l_loc_str);
+                }
+                else
+                {
+                    TARGETING::EntityPath ep =
+                      l_mb->getAttr<TARGETING::ATTR_PHYS_PATH>();
+                    i_dt->addPropertyString(membNode, "ibm,slot-location-code",
+                                            ep.toString());
+                }
+            }
 
             // Add dimm info
             errhdl = bld_fdt_dimm(i_dt, membNode, l_mb);
@@ -2236,8 +2362,6 @@ errlHndl_t bld_fdt_mem(devTree * i_dt, bool i_smallTree)
                 continue;
             }
 
-            i_dt->addProperty(membNode, "present");
-
             //Add some info to the memory buffer
             i_dt->addPropertyCell32(membNode, "frequency-mhz",
                                     l_mb->getAttr<TARGETING::ATTR_MSS_FREQ>());
@@ -2249,14 +2373,16 @@ errlHndl_t bld_fdt_mem(devTree * i_dt, bool i_smallTree)
             if(l_mb->getAttr<TARGETING::ATTR_CENTAUR_ECID_FRU_ID>() == 0xFF)
             {
                 //Add Product Part Number
-                TARGETING::ATTR_PART_NUMBER_type l_pn = {'0'};
+                TARGETING::ATTR_PART_NUMBER_type l_pn = {'\0'};
                 l_mb->tryGetAttr<TARGETING::ATTR_PART_NUMBER>(l_pn);
+                str_chomp(reinterpret_cast<char*>(&l_pn[0]));
                 i_dt->addPropertyString(membNode, "part-number",
                                         reinterpret_cast<char*>(&l_pn[0]));
 
                 //Add Product Serial Number
-                TARGETING::ATTR_SERIAL_NUMBER_type l_sn = {'0'};
+                TARGETING::ATTR_SERIAL_NUMBER_type l_sn = {'\0'};
                 l_mb->tryGetAttr<TARGETING::ATTR_SERIAL_NUMBER>(l_sn);
+                str_chomp(reinterpret_cast<char*>(&l_sn[0]));
                 i_dt->addPropertyString(membNode, "serial-number",
                                         reinterpret_cast<char*>(&l_sn[0]));
 
@@ -2265,6 +2391,7 @@ errlHndl_t bld_fdt_mem(devTree * i_dt, bool i_smallTree)
                                  CVPD::OPFR, CVPD::DR);
                 if (errhdl) { break; }
                 l_data.push_back('\0');
+                str_chomp(reinterpret_cast<char*>(&l_data[0]));
                 i_dt->addPropertyString(membNode, "board-info",
                                         reinterpret_cast<char*>(&l_data[0]));
 
@@ -2273,18 +2400,23 @@ errlHndl_t bld_fdt_mem(devTree * i_dt, bool i_smallTree)
                                  CVPD::OPFR, CVPD::VN);
                 if (errhdl) { break; }
                 l_data.push_back('\0');
+                str_chomp(reinterpret_cast<char*>(&l_data[0]));
                 i_dt->addPropertyString(membNode, "vendor",
                                         reinterpret_cast<char*>(&l_data[0]));
             }
 
-            //Set property to indicate fault (not using)
-            //and don't add anything else (OPAL keys off of it to
-            //actively use the chip)
+            //Set property to indicate disabled (not using)
+            //and don't add anything else (OPAL keys off of the rest
+            //of the dev tree info to actively use the chip)
             if(l_mb->getAttr<TARGETING::ATTR_HWAS_STATE>().functional != true)
             {
-                i_dt->addProperty(membNode, "fault");
+                i_dt->addPropertyString(membNode, "status", "disabled");
                 continue;
             }
+            else
+            {
+                i_dt->addPropertyString(membNode, "status", "okay");
+            }
 
             // Add membuf ECIDs
             ATTR_ECID_type ecid;
@@ -2765,6 +2897,73 @@ void bld_fdt_mnfgMode(devTree * i_dt, bool i_smallTree)
     return;
 }
 
+void parse_add_version_str(devTree * i_dt, dtOffset_t& i_fwNode, char* i_ver)
+{
+    // PNOR version strings are not easily consumable
+    // Split them up into property/version
+    // The following strings are supported:
+    const char * cmp_str[] = {"open-power", "buildroot", "skiboot",
+    "hostboot-binaries", "hostboot", "linux", "petitboot", "occ",
+    "capp-ucode"};
+    bool found = false;
+    size_t ver_len = strlen(i_ver);
+
+    // Loop on all strings looking for a match
+    // Example input is
+    //   "open-power-firestone-v1.8"
+    //   "linux-4.4.6-openpower1-8420e0f"
+    // Desired output in devtree is
+    //   open-power = "firestone-v1.8";
+    //   linux = "4.4.6-openpower1-8420e0f";
+    for(size_t i = 0; i < (sizeof(cmp_str)/sizeof(cmp_str[0])) && !found; i++)
+    {
+        //If the size of the input is less than search key, can't be it... skip
+        size_t key_len = strlen(cmp_str[i]);
+        if (ver_len < key_len) continue;
+
+        if(memcmp(i_ver, cmp_str[i], key_len) == 0)
+        {
+            //Found a match, copy
+            char * l_prop = i_ver+key_len+1; //increment past "key-"
+            i_dt->addPropertyString(i_fwNode, cmp_str[i], l_prop );
+            found = true; //Stop looking
+        }
+    }
+
+    // If not found need to check for "xml" as it doesn't follow a well known
+    // pattern since the system name is in the key
+    // ie "firestone-xml-15e3718" --> firestone-xml = "15e3718"
+    if(!found)
+    {
+        const char * l_key = "xml";
+        char * loc =
+         reinterpret_cast<char*> (memmem(i_ver, ver_len, l_key, strlen(l_key)));
+        if(loc) //Found
+        {
+            //Drop a NULL char in the "-" after the xml to make two strings
+            size_t l_endofprop = (loc-i_ver) + strlen(l_key);
+            i_ver[l_endofprop] = NULL;
+            char * l_prop = i_ver+l_endofprop+1; //increment past "key-"
+            i_dt->addPropertyString(i_fwNode, i_ver, l_prop );
+            found = true; //Stop looking
+        }
+    }
+
+    // If didn't find any expected key
+    // just add as key to first '-', and everything after is property value
+    if(!found)
+    {
+        char* l_loc = strchr(i_ver, '-');
+        if(l_loc) //Found
+        {
+            //Drop a NULL char in the found "-" to make two strings
+            *l_loc = '\0';
+            l_loc++;
+            i_dt->addPropertyString(i_fwNode, i_ver, l_loc );
+        }
+    }
+}
+
 errlHndl_t bld_fdt_fw_info(devTree * i_dt, bool i_smallTree)
 {
     // Nothing to do for small trees currently.
@@ -2778,7 +2977,7 @@ errlHndl_t bld_fdt_fw_info(devTree * i_dt, bool i_smallTree)
     {
         /* Find the / node and add a vpd node under it. */
         dtOffset_t rootNode = i_dt->findNode("/");
-        dtOffset_t fwNode = i_dt->addNode(rootNode, "ibm,firmware");
+        dtOffset_t fwNode = i_dt->addNode(rootNode, "ibm,firmware-versions");
 
         // Grab a system object to work with
         TARGETING::Target* sys = NULL;
@@ -2803,7 +3002,8 @@ errlHndl_t bld_fdt_fw_info(devTree * i_dt, bool i_smallTree)
             {
                 //Add existing version string
                 l_data.push_back('\0');
-                i_dt->addProperty(fwNode,reinterpret_cast<char*>(&l_data[0]));
+                parse_add_version_str(i_dt, fwNode,
+                                      reinterpret_cast<char*>(&l_data[0]));
 
                 //Clear for next version string
                 l_data.clear();
diff --git a/src/usr/targeting/common/Targets.pm b/src/usr/targeting/common/Targets.pm
index dffb5fa..4fd6e2d 100644
--- a/src/usr/targeting/common/Targets.pm
+++ b/src/usr/targeting/common/Targets.pm
@@ -182,7 +182,6 @@ sub printAttribute
     $filter{PCIE_NUM_LANES}                 = 1;
     $filter{PHB_NUM}                        = 1;
     $filter{IOP_NUM}                        = 1;
-    $filter{LOCATION_CODE}                  = 1;
     $filter{MCS_NUM}                        = 1;
     $filter{SCHEMATIC_INTERFACE}            = 1;
     $filter{ENTITY_ID}                      = 1;
diff --git a/src/usr/targeting/common/processMrw.pl b/src/usr/targeting/common/processMrw.pl
index 386212c..2aafbda 100644
--- a/src/usr/targeting/common/processMrw.pl
+++ b/src/usr/targeting/common/processMrw.pl
@@ -409,6 +409,28 @@ sub processBmc
     }
 }
 
+sub customizeLocation
+{
+    my $targetObj = shift;
+    my $target = shift;
+
+    ##If this target is on a daughter card/socket serverwiz only represents a
+    ##single instance and the unique location code is on the connector.  Search
+    ##for a connector in the parent tree -- if found then set, otherwise don't
+    ##touch
+    my $parent_target = $targetObj->getTargetParent($target);
+    while ( $targetObj->getTargetType($parent_target) ne "card-motherboard" ) {
+        my $parent_class = $targetObj->getAttribute($parent_target, "CLASS");
+        if ( $parent_class eq "CONNECTOR" ) {
+            $targetObj->copyAttribute($parent_target,$target,"LOCATION_CODE");
+            last;
+        }
+
+        #get parent's parent
+        $parent_target = $targetObj->getTargetParent($parent_target);
+    }
+ }
+
 
 sub parseBitwise
 {
@@ -444,12 +466,10 @@ sub processProcessor
     ## The grandparent is guaranteed to be socket.
     my $socket_target =
        $targetObj->getTargetParent($targetObj->getTargetParent($target));
-    $targetObj->copyAttribute($socket_target,$target,"LOCATION_CODE");
 
     ## Module attibutes are inherited into the proc target
     my $module_target =
        $targetObj->getTargetParent($target);
-    $targetObj->copyAttribute($module_target,$target,"LOCATION_CODE");
 
     ## Copy all attributes from module
     foreach my $attr (sort (keys
@@ -458,6 +478,8 @@ sub processProcessor
         $targetObj->copyAttribute($module_target,$target,$attr);
     }
 
+    customizeLocation($targetObj,$target);
+
     ## Copy PCIE attributes from socket
     ## Copy Position attribute from socket
     foreach my $attr (sort (keys
@@ -1098,6 +1120,8 @@ sub processMembuf
         return;
     }
 
+    customizeLocation($targetObj,$target);
+
     processMembufVpdAssociation($targetObj,$target);
 
     ## finds which gpio expander that controls vddr regs for membufs
@@ -1145,6 +1169,14 @@ sub processMembuf
          }
     }
 
+    ## Customize all the dimm locations under this membuf
+    my $dimms=$targetObj->findConnections($target,"I2C","SPD");
+    if ($dimms ne "") {
+        foreach my $dimm (@{$dimms->{CONN}}) {
+            my $dimm_target = $targetObj->getTargetParent($dimm->{DEST_PARENT});
+            customizeLocation($targetObj, $dimm_target);
+        }
+    }
 
     ## Process MEMBUF to DIMM I2C connections
     my @addr_map=('0','0','0','0','0','0','0','0');
diff --git a/src/usr/targeting/common/xmltohb/attribute_types_hb.xml b/src/usr/targeting/common/xmltohb/attribute_types_hb.xml
index b583e0a..a8a14e1 100644
--- a/src/usr/targeting/common/xmltohb/attribute_types_hb.xml
+++ b/src/usr/targeting/common/xmltohb/attribute_types_hb.xml
@@ -1344,6 +1344,22 @@ ID for the sensor number returned with the elog. -->
 </attribute>
 
 <attribute>
+    <id>LOCATION_CODE</id>
+    <description>Location string for OpenPOWER (only). Used in open power
+        systems to indicate the location of the part.  Typically the same
+        as the silkscreen on the motherboard.
+    </description>
+    <simpleType>
+        <string>
+            <default>undef</default>
+            <sizeInclNull>32</sizeInclNull>
+        </string>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+</attribute>
+
+<attribute>
     <id>MBVPD_VERSION</id>
     <description>MBVPD Version
     </description>
diff --git a/src/usr/targeting/common/xmltohb/target_types_hb.xml b/src/usr/targeting/common/xmltohb/target_types_hb.xml
index ab85a5f..2e2c53f 100644
--- a/src/usr/targeting/common/xmltohb/target_types_hb.xml
+++ b/src/usr/targeting/common/xmltohb/target_types_hb.xml
@@ -104,6 +104,11 @@
 </targetTypeExtension>
 
 <targetTypeExtension>
+    <id>chip</id>
+    <attribute><id>LOCATION_CODE</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
     <id>chip-processor</id>
     <attribute>
         <id>FSI_MASTER_MUTEX</id>
@@ -240,6 +245,11 @@
 </targetTypeExtension>
 
 <targetTypeExtension>
+    <id>lcard-dimm-jedec</id>
+    <attribute><id>LOCATION_CODE</id></attribute>
+</targetTypeExtension>
+
+<targetTypeExtension>
     <id>occ</id>
     <attribute>
         <id>PSTATE_TABLE</id>
diff --git a/src/usr/targeting/common/xmltohb/xmltohb.pl b/src/usr/targeting/common/xmltohb/xmltohb.pl
index d250642..34b3efc 100755
--- a/src/usr/targeting/common/xmltohb/xmltohb.pl
+++ b/src/usr/targeting/common/xmltohb/xmltohb.pl
@@ -201,6 +201,8 @@ else
     handleTgtPtrAttributesHb(\$attributes, \%Target_t);
 }
 
+cleanupNullStrAttributeDefaults($attributes);
+
 # Open the output files and write them
 if( !($cfgSrcOutputDir =~ "none") )
 {
@@ -703,6 +705,48 @@ sub getPeerHuid
     return $peerHUID;
 }
 
+sub cleanupNullStrAttributeDefaults
+{
+    my($attributes) = @_;
+
+
+    ## The perl xml parser will convert a "empty" default ATTR
+    ## type for a string into a hash -- which will result in a
+    ## string of "0" being placed in the bin instead of ""
+    ## Real strings work fine though -- go figure.  Do a simple
+    ## loop to clean them up
+
+    my %strAttrList;
+
+    ## Build list of ATTR that are <simpleType><string>
+    foreach my $attribute (@{$attributes->{attribute}})
+    {
+        if (exists $attribute->{simpleType} &&
+            exists $attribute->{simpleType}->{string})
+        {
+            #Only add once
+            if(!exists($strAttrList{$attribute->{id}}))
+            {
+                $strAttrList{$attribute->{id}} = 1;
+            }
+        }
+    }
+
+    foreach my $targetInstance (@{$attributes->{targetInstance}})
+    {
+        foreach my $attr (@{$targetInstance->{attribute}})
+        {
+            if (exists $attr->{default} &&
+                exists $strAttrList{$attr->{id}} &&
+                (ref $attr->{default} eq ref {}))
+            {
+                $attr->{default} = "";
+            }
+        }
+    }
+}
+
+
 sub SOURCE_FILE_GENERATION_FUNCTIONS { }
 
 ################################################################################
-- 
2.6.2.windows.1

